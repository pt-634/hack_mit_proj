{"ast":null,"code":"'use strict';\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === 'm') throw new TypeError('Private method is not writable');\n  if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a setter');\n  if (typeof state === 'function' ? receiver !== state || !f : !state.has(receiver)) throw new TypeError('Cannot write private member to an object whose class did not declare it');\n  return kind === 'a' ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a getter');\n  if (typeof state === 'function' ? receiver !== state || !f : !state.has(receiver)) throw new TypeError('Cannot read private member from an object whose class did not declare it');\n  return kind === 'm' ? f : kind === 'a' ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.toBase64 = exports.getHeader = exports.isHeadersProtocol = exports.isRunningInBrowser = exports.debug = exports.hasOwn = exports.isEmptyObj = exports.maybeCoerceBoolean = exports.maybeCoerceFloat = exports.maybeCoerceInteger = exports.coerceBoolean = exports.coerceFloat = exports.coerceInteger = exports.readEnv = exports.ensurePresent = exports.castToError = exports.safeJSON = exports.isRequestOptions = exports.createResponseHeaders = exports.PagePromise = exports.AbstractPage = exports.APIResource = exports.APIClient = exports.APIPromise = exports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = void 0;\nconst version_1 = require('./version.js');\nconst streaming_1 = require('./streaming.js');\nconst error_1 = require('./error.js');\nconst agent_1 = require('openai/_shims/agent');\nconst fetch_1 = require('openai/_shims/fetch');\nconst uploads_1 = require('./uploads.js');\nvar uploads_2 = require('./uploads.js');\nObject.defineProperty(exports, 'maybeMultipartFormRequestOptions', {\n  enumerable: true,\n  get: function () {\n    return uploads_2.maybeMultipartFormRequestOptions;\n  }\n});\nObject.defineProperty(exports, 'multipartFormRequestOptions', {\n  enumerable: true,\n  get: function () {\n    return uploads_2.multipartFormRequestOptions;\n  }\n});\nObject.defineProperty(exports, 'createForm', {\n  enumerable: true,\n  get: function () {\n    return uploads_2.createForm;\n  }\n});\nconst MAX_RETRIES = 2;\nasync function defaultParseResponse(props) {\n  const {\n    response\n  } = props;\n  if (props.options.stream) {\n    // Note: there is an invariant here that isn't represented in the type system\n    // that if you set `stream: true` the response type must also be `Stream<T>`\n    return new streaming_1.Stream(response, props.controller);\n  }\n  const contentType = response.headers.get('content-type');\n  if (contentType === null || contentType === void 0 ? void 0 : contentType.includes('application/json')) {\n    const json = await response.json();\n    debug('response', response.status, response.url, response.headers, json);\n    return json;\n  }\n  // TODO handle blob, arraybuffer, other content types, etc.\n  const text = await response.text();\n  debug('response', response.status, response.url, response.headers, text);\n  return text;\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nclass APIPromise extends Promise {\n  constructor(responsePromise, parseResponse = defaultParseResponse) {\n    super(resolve => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null);\n    });\n    this.responsePromise = responsePromise;\n    this.parseResponse = parseResponse;\n  }\n  _thenUnwrap(transform) {\n    return new APIPromise(this.responsePromise, async props => transform(await this.parseResponse(props)));\n  }\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   */\n  asResponse() {\n    return this.responsePromise.then(p => p.response);\n  }\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   */\n  async withResponse() {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return {\n      data,\n      response\n    };\n  }\n  parse() {\n    if (!this.parsedPromise) {\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\n    }\n    return this.parsedPromise;\n  }\n  then(onfulfilled, onrejected) {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n  catch(onrejected) {\n    return this.parse().catch(onrejected);\n  }\n  finally(onfinally) {\n    return this.parse().finally(onfinally);\n  }\n}\nexports.APIPromise = APIPromise;\nclass APIClient {\n  constructor({\n    baseURL,\n    maxRetries,\n    timeout = 600000,\n    // 10 minutes\n    httpAgent,\n    fetch: overridenFetch\n  }) {\n    this.baseURL = baseURL;\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries !== null && maxRetries !== void 0 ? maxRetries : MAX_RETRIES);\n    this.timeout = validatePositiveInteger('timeout', timeout);\n    this.httpAgent = httpAgent;\n    this.fetch = overridenFetch !== null && overridenFetch !== void 0 ? overridenFetch : fetch_1.fetch;\n  }\n  authHeaders() {\n    return {};\n  }\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n  defaultHeaders() {\n    return {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'User-Agent': this.getUserAgent(),\n      ...getPlatformHeaders(),\n      ...this.authHeaders()\n    };\n  }\n  /**\n   * Override this to add your own headers validation:\n   */\n  validateHeaders(headers, customHeaders) {}\n  defaultIdempotencyKey() {\n    return `stainless-node-retry-${uuid4()}`;\n  }\n  get(path, opts) {\n    return this.methodRequest('get', path, opts);\n  }\n  post(path, opts) {\n    return this.methodRequest('post', path, opts);\n  }\n  patch(path, opts) {\n    return this.methodRequest('patch', path, opts);\n  }\n  put(path, opts) {\n    return this.methodRequest('put', path, opts);\n  }\n  delete(path, opts) {\n    return this.methodRequest('delete', path, opts);\n  }\n  methodRequest(method, path, opts) {\n    return this.request(Promise.resolve(opts).then(opts => ({\n      method,\n      path,\n      ...opts\n    })));\n  }\n  getAPIList(path, Page, opts) {\n    return this.requestAPIList(Page, {\n      method: 'get',\n      path,\n      ...opts\n    });\n  }\n  calculateContentLength(body) {\n    if (typeof body === 'string') {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(body, 'utf8').toString();\n      }\n      if (typeof TextEncoder !== 'undefined') {\n        const encoder = new TextEncoder();\n        const encoded = encoder.encode(body);\n        return encoded.length.toString();\n      }\n    }\n    return null;\n  }\n  buildRequest(options) {\n    var _a, _b, _c, _d, _e, _f;\n    const {\n      method,\n      path,\n      query,\n      headers = {}\n    } = options;\n    const body = (0, uploads_1.isMultipartBody)(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;\n    const contentLength = this.calculateContentLength(body);\n    const url = this.buildURL(path, query);\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\n    const timeout = (_a = options.timeout) !== null && _a !== void 0 ? _a : this.timeout;\n    const httpAgent = (_c = (_b = options.httpAgent) !== null && _b !== void 0 ? _b : this.httpAgent) !== null && _c !== void 0 ? _c : (0, agent_1.getDefaultAgent)(url);\n    const minAgentTimeout = timeout + 1000;\n    if (typeof ((_d = httpAgent === null || httpAgent === void 0 ? void 0 : httpAgent.options) === null || _d === void 0 ? void 0 : _d.timeout) === 'number' && minAgentTimeout > ((_e = httpAgent.options.timeout) !== null && _e !== void 0 ? _e : 0)) {\n      // Allow any given request to bump our agent active socket timeout.\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n      // and without mutating agent we would need to create more of them.\n      // This tradeoff optimizes for performance.\n      httpAgent.options.timeout = minAgentTimeout;\n    }\n    if (this.idempotencyHeader && method !== 'get') {\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n      headers[this.idempotencyHeader] = options.idempotencyKey;\n    }\n    const reqHeaders = {\n      ...(contentLength && {\n        'Content-Length': contentLength\n      }),\n      ...this.defaultHeaders(),\n      ...headers\n    };\n    // let builtin fetch set the Content-Type for multipart bodies\n    if ((0, uploads_1.isMultipartBody)(options.body) && !fetch_1.isPolyfilled) {\n      delete reqHeaders['Content-Type'];\n    }\n    // Strip any headers being explicitly omitted with null\n    Object.keys(reqHeaders).forEach(key => reqHeaders[key] === null && delete reqHeaders[key]);\n    const req = {\n      method,\n      ...(body && {\n        body: body\n      }),\n      headers: reqHeaders,\n      ...(httpAgent && {\n        agent: httpAgent\n      }),\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: (_f = options.signal) !== null && _f !== void 0 ? _f : null\n    };\n    this.validateHeaders(reqHeaders, headers);\n    return {\n      req,\n      url,\n      timeout\n    };\n  }\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n  async prepareRequest(request, {\n    url\n  }) {}\n  makeStatusError(status, error, message, headers) {\n    return error_1.APIError.generate(status, error, message, headers);\n  }\n  request(options, remainingRetries = null) {\n    return new APIPromise(this.makeRequest(options, remainingRetries));\n  }\n  async makeRequest(optionsInput, retriesRemaining) {\n    var _a, _b, _c;\n    const options = await optionsInput;\n    if (retriesRemaining == null) {\n      retriesRemaining = (_a = options.maxRetries) !== null && _a !== void 0 ? _a : this.maxRetries;\n    }\n    const {\n      req,\n      url,\n      timeout\n    } = this.buildRequest(options);\n    await this.prepareRequest(req, {\n      url\n    });\n    debug('request', url, options, req.headers);\n    if ((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n      throw new error_1.APIUserAbortError();\n    }\n    const controller = new AbortController();\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(exports.castToError);\n    if (response instanceof Error) {\n      if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {\n        throw new error_1.APIUserAbortError();\n      }\n      if (retriesRemaining) {\n        return this.retryRequest(options, retriesRemaining);\n      }\n      if (response.name === 'AbortError') {\n        throw new error_1.APIConnectionTimeoutError();\n      }\n      throw new error_1.APIConnectionError({\n        cause: response\n      });\n    }\n    const responseHeaders = (0, exports.createResponseHeaders)(response.headers);\n    if (!response.ok) {\n      if (retriesRemaining && this.shouldRetry(response)) {\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\n      }\n      const errText = await response.text().catch(() => 'Unknown');\n      const errJSON = (0, exports.safeJSON)(errText);\n      const errMessage = errJSON ? undefined : errText;\n      debug('response', response.status, url, responseHeaders, errMessage);\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n      throw err;\n    }\n    return {\n      response,\n      options,\n      controller\n    };\n  }\n  requestAPIList(Page, options) {\n    const request = this.makeRequest(options, null);\n    return new PagePromise(this, request, Page);\n  }\n  buildURL(path, query) {\n    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n    const defaultQuery = this.defaultQuery();\n    if (!isEmptyObj(defaultQuery)) {\n      query = {\n        ...defaultQuery,\n        ...query\n      };\n    }\n    if (query) {\n      url.search = this.stringifyQuery(query);\n    }\n    return url.toString();\n  }\n  stringifyQuery(query) {\n    return Object.entries(query).filter(([_, value]) => typeof value !== 'undefined').map(([key, value]) => {\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n      }\n      if (value === null) {\n        return `${encodeURIComponent(key)}=`;\n      }\n      throw new Error(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n    }).join('&');\n  }\n  async fetchWithTimeout(url, init, ms, controller) {\n    const {\n      signal,\n      ...options\n    } = init || {};\n    if (signal) signal.addEventListener('abort', () => controller.abort());\n    const timeout = setTimeout(() => controller.abort(), ms);\n    return this.getRequestClient().fetch(url, {\n      signal: controller.signal,\n      ...options\n    }).finally(() => {\n      clearTimeout(timeout);\n    });\n  }\n  getRequestClient() {\n    return {\n      fetch: this.fetch\n    };\n  }\n  shouldRetry(response) {\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get('x-should-retry');\n    // If the server explicitly says whether or not to retry, obey.\n    if (shouldRetryHeader === 'true') return true;\n    if (shouldRetryHeader === 'false') return false;\n    // Retry on lock timeouts.\n    if (response.status === 409) return true;\n    // Retry on rate limits.\n    if (response.status === 429) return true;\n    // Retry internal errors.\n    if (response.status >= 500) return true;\n    return false;\n  }\n  async retryRequest(options, retriesRemaining, responseHeaders) {\n    var _a;\n    retriesRemaining -= 1;\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n    //\n    // TODO: we may want to handle the case where the header is using the http-date syntax: \"Retry-After: <http-date>\".\n    // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#syntax for details.\n    const retryAfter = parseInt((responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders['retry-after']) || '');\n    const maxRetries = (_a = options.maxRetries) !== null && _a !== void 0 ? _a : this.maxRetries;\n    const timeout = this.calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) * 1000;\n    await sleep(timeout);\n    return this.makeRequest(options, retriesRemaining);\n  }\n  calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) {\n    const initialRetryDelay = 0.5;\n    const maxRetryDelay = 2;\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n    // just do what it says.\n    if (Number.isInteger(retryAfter) && retryAfter <= 60) {\n      return retryAfter;\n    }\n    const numRetries = maxRetries - retriesRemaining;\n    // Apply exponential backoff, but not more than the max.\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(numRetries - 1, 2), maxRetryDelay);\n    // Apply some jitter, plus-or-minus half a second.\n    const jitter = Math.random() - 0.5;\n    return sleepSeconds + jitter;\n  }\n  getUserAgent() {\n    return `${this.constructor.name}/JS ${version_1.VERSION}`;\n  }\n}\nexports.APIClient = APIClient;\nclass APIResource {\n  constructor(client) {\n    this.client = client;\n    this.get = client.get.bind(client);\n    this.post = client.post.bind(client);\n    this.patch = client.patch.bind(client);\n    this.put = client.put.bind(client);\n    this.delete = client.delete.bind(client);\n    this.getAPIList = client.getAPIList.bind(client);\n  }\n}\nexports.APIResource = APIResource;\nclass AbstractPage {\n  constructor(client, response, body, options) {\n    _AbstractPage_client.set(this, void 0);\n    __classPrivateFieldSet(this, _AbstractPage_client, client, 'f');\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n  hasNextPage() {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageInfo() != null;\n  }\n  async getNextPage() {\n    const nextInfo = this.nextPageInfo();\n    if (!nextInfo) {\n      throw new Error('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n    }\n    const nextOptions = {\n      ...this.options\n    };\n    if ('params' in nextInfo) {\n      nextOptions.query = {\n        ...nextOptions.query,\n        ...nextInfo.params\n      };\n    } else if ('url' in nextInfo) {\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n      for (const [key, value] of params) {\n        nextInfo.url.searchParams.set(key, value);\n      }\n      nextOptions.query = undefined;\n      nextOptions.path = nextInfo.url.toString();\n    }\n    return await __classPrivateFieldGet(this, _AbstractPage_client, 'f').requestAPIList(this.constructor, nextOptions);\n  }\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n  async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\nexports.AbstractPage = AbstractPage;\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nclass PagePromise extends APIPromise {\n  constructor(client, request, Page) {\n    super(request, async props => new Page(client, props.response, await defaultParseResponse(props), props.options));\n  }\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\nexports.PagePromise = PagePromise;\nconst createResponseHeaders = headers => {\n  return new Proxy(Object.fromEntries(\n  // @ts-ignore\n  headers.entries()), {\n    get(target, name) {\n      const key = name.toString();\n      return target[key.toLowerCase()] || target[key];\n    }\n  });\n};\nexports.createResponseHeaders = createResponseHeaders;\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n  method: true,\n  path: true,\n  query: true,\n  body: true,\n  headers: true,\n  maxRetries: true,\n  stream: true,\n  timeout: true,\n  httpAgent: true,\n  signal: true,\n  idempotencyKey: true\n};\nconst isRequestOptions = obj => {\n  return typeof obj === 'object' && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every(k => hasOwn(requestOptionsKeys, k));\n};\nexports.isRequestOptions = isRequestOptions;\nconst getPlatformProperties = () => {\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': version_1.VERSION,\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n      'X-Stainless-Runtime': 'deno',\n      'X-Stainless-Runtime-Version': Deno.version\n    };\n  }\n  if (typeof EdgeRuntime !== 'undefined') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': version_1.VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\n      'X-Stainless-Runtime': 'edge',\n      'X-Stainless-Runtime-Version': process.version\n    };\n  }\n  // Check if Node.js\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': version_1.VERSION,\n      'X-Stainless-OS': normalizePlatform(process.platform),\n      'X-Stainless-Arch': normalizeArch(process.arch),\n      'X-Stainless-Runtime': 'node',\n      'X-Stainless-Runtime-Version': process.version\n    };\n  }\n  const browserInfo = getBrowserInfo();\n  if (browserInfo) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': version_1.VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': 'unknown',\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n      'X-Stainless-Runtime-Version': browserInfo.version\n    };\n  }\n  // TODO add support for Cloudflare workers, etc.\n  return {\n    'X-Stainless-Lang': 'js',\n    'X-Stainless-Package-Version': version_1.VERSION,\n    'X-Stainless-OS': 'Unknown',\n    'X-Stainless-Arch': 'unknown',\n    'X-Stainless-Runtime': 'unknown',\n    'X-Stainless-Runtime-Version': 'unknown'\n  };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n  if (!navigator || typeof navigator === 'undefined') {\n    return null;\n  }\n  // NOTE: The order matters here!\n  const browserPatterns = [{\n    key: 'edge',\n    pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'ie',\n    pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'ie',\n    pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'chrome',\n    pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'firefox',\n    pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'safari',\n    pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/\n  }];\n  // Find the FIRST matching browser\n  for (const {\n    key,\n    pattern\n  } of browserPatterns) {\n    const match = pattern.exec(navigator.userAgent);\n    if (match) {\n      const major = match[1] || 0;\n      const minor = match[2] || 0;\n      const patch = match[3] || 0;\n      return {\n        browser: key,\n        version: `${major}.${minor}.${patch}`\n      };\n    }\n  }\n  return null;\n}\nconst normalizeArch = arch => {\n  // Node docs:\n  // - https://nodejs.org/api/process.html#processarch\n  // Deno docs:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  if (arch === 'x32') return 'x32';\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\n  if (arch === 'arm') return 'arm';\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\n  if (arch) return `other:${arch}`;\n  return 'unknown';\n};\nconst normalizePlatform = platform => {\n  // Node platforms:\n  // - https://nodejs.org/api/process.html#processplatform\n  // Deno platforms:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  // - https://github.com/denoland/deno/issues/14799\n  platform = platform.toLowerCase();\n  // NOTE: this iOS check is untested and may not work\n  // Node does not work natively on IOS, there is a fork at\n  // https://github.com/nodejs-mobile/nodejs-mobile\n  // however it is unknown at the time of writing how to detect if it is running\n  if (platform.includes('ios')) return 'iOS';\n  if (platform === 'android') return 'Android';\n  if (platform === 'darwin') return 'MacOS';\n  if (platform === 'win32') return 'Windows';\n  if (platform === 'freebsd') return 'FreeBSD';\n  if (platform === 'openbsd') return 'OpenBSD';\n  if (platform === 'linux') return 'Linux';\n  if (platform) return `Other:${platform}`;\n  return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n  return _platformHeaders !== null && _platformHeaders !== void 0 ? _platformHeaders : _platformHeaders = getPlatformProperties();\n};\nconst safeJSON = text => {\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return undefined;\n  }\n};\nexports.safeJSON = safeJSON;\n// https://stackoverflow.com/a/19709846\nconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\nconst isAbsoluteURL = url => {\n  return startsWithSchemeRegexp.test(url);\n};\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst validatePositiveInteger = (name, n) => {\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\n    throw new Error(`${name} must be an integer`);\n  }\n  if (n < 0) {\n    throw new Error(`${name} must be a positive integer`);\n  }\n  return n;\n};\nconst castToError = err => {\n  if (err instanceof Error) return err;\n  return new Error(err);\n};\nexports.castToError = castToError;\nconst ensurePresent = value => {\n  if (value == null) throw new Error(`Expected a value to be given but received ${value} instead.`);\n  return value;\n};\nexports.ensurePresent = ensurePresent;\n/**\n * Read an environment variable.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nconst readEnv = env => {\n  var _a, _b, _c, _d;\n  if (typeof process !== 'undefined') {\n    return (_b = (_a = process.env) === null || _a === void 0 ? void 0 : _a[env]) !== null && _b !== void 0 ? _b : undefined;\n  }\n  if (typeof Deno !== 'undefined') {\n    return (_d = (_c = Deno.env) === null || _c === void 0 ? void 0 : _c.get) === null || _d === void 0 ? void 0 : _d.call(_c, env);\n  }\n  return undefined;\n};\nexports.readEnv = readEnv;\nconst coerceInteger = value => {\n  if (typeof value === 'number') return Math.round(value);\n  if (typeof value === 'string') return parseInt(value, 10);\n  throw new Error(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexports.coerceInteger = coerceInteger;\nconst coerceFloat = value => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') return parseFloat(value);\n  throw new Error(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexports.coerceFloat = coerceFloat;\nconst coerceBoolean = value => {\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'string') return value === 'true';\n  return Boolean(value);\n};\nexports.coerceBoolean = coerceBoolean;\nconst maybeCoerceInteger = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return (0, exports.coerceInteger)(value);\n};\nexports.maybeCoerceInteger = maybeCoerceInteger;\nconst maybeCoerceFloat = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return (0, exports.coerceFloat)(value);\n};\nexports.maybeCoerceFloat = maybeCoerceFloat;\nconst maybeCoerceBoolean = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return (0, exports.coerceBoolean)(value);\n};\nexports.maybeCoerceBoolean = maybeCoerceBoolean;\n// https://stackoverflow.com/a/34491287\nfunction isEmptyObj(obj) {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\nexports.isEmptyObj = isEmptyObj;\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexports.hasOwn = hasOwn;\nfunction debug(action, ...args) {\n  if (typeof process !== 'undefined' && process.env['DEBUG'] === 'true') {\n    console.log(`OpenAI:DEBUG:${action}`, ...args);\n  }\n}\nexports.debug = debug;\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n};\nconst isRunningInBrowser = () => {\n  return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n    // @ts-ignore\n    typeof window.document !== 'undefined' &&\n    // @ts-ignore\n    typeof navigator !== 'undefined'\n  );\n};\nexports.isRunningInBrowser = isRunningInBrowser;\nconst isHeadersProtocol = headers => {\n  return typeof (headers === null || headers === void 0 ? void 0 : headers.get) === 'function';\n};\nexports.isHeadersProtocol = isHeadersProtocol;\nconst getHeader = (headers, key) => {\n  const lowerKey = key.toLowerCase();\n  if ((0, exports.isHeadersProtocol)(headers)) return headers.get(key) || headers.get(lowerKey);\n  const value = headers[key] || headers[lowerKey];\n  if (Array.isArray(value)) {\n    if (value.length <= 1) return value[0];\n    console.warn(`Received ${value.length} entries for the ${key} header, using the first entry.`);\n    return value[0];\n  }\n  return value;\n};\nexports.getHeader = getHeader;\n/**\n * Encodes a string to Base64 format.\n */\nconst toBase64 = str => {\n  if (!str) return '';\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str).toString('base64');\n  }\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n  throw new Error('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\nexports.toBase64 = toBase64;","map":{"version":3,"names":["__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","_AbstractPage_client","exports","toBase64","getHeader","isHeadersProtocol","isRunningInBrowser","debug","hasOwn","isEmptyObj","maybeCoerceBoolean","maybeCoerceFloat","maybeCoerceInteger","coerceBoolean","coerceFloat","coerceInteger","readEnv","ensurePresent","isRequestOptions","createResponseHeaders","PagePromise","AbstractPage","multipartFormRequestOptions","maybeMultipartFormRequestOptions","version_1","require","streaming_1","agent_1","fetch_1","uploads_2","defineProperty","createForm","defaultParseResponse","props","response","options","stream","Stream","controller","contentType","headers","includes","json","status","url","text","Promise","constructor","responsePromise","parseResponse","resolve","APIPromise","transform","asResponse","then","p","withResponse","data","all","parse","parsedPromise","onfulfilled","onrejected","catch","finally","onfinally","baseURL","maxRetries","validatePositiveInteger","MAX_RETRIES","httpAgent","fetch","overridenFetch","defaultHeaders","getUserAgent","getPlatformHeaders","authHeaders","validateHeaders","customHeaders","defaultIdempotencyKey","uuid4","opts","methodRequest","path","method","request","body","Buffer","byteLength","toString","TextEncoder","encoder","encoded","encode","length","buildRequest","_b","_c","_d","_e","_f","query","uploads_1","isMultipartBody","JSON","stringify","contentLength","calculateContentLength","buildURL","timeout","_a","getDefaultAgent","minAgentTimeout","idempotencyHeader","idempotencyKey","reqHeaders","isPolyfilled","keys","forEach","key","agent","signal","req","prepareRequest","makeStatusError","error","message","error_1","APIError","generate","remainingRetries","makeRequest","optionsInput","retriesRemaining","aborted","APIUserAbortError","AbortController","fetchWithTimeout","castToError","Error","retryRequest","name","APIConnectionTimeoutError","APIConnectionError","cause","responseHeaders","shouldRetry","errText","errJSON","safeJSON","errMessage","undefined","err","requestAPIList","Page","URL","endsWith","startsWith","slice","defaultQuery","search","stringifyQuery","Object","entries","filter","_","encodeURIComponent","join","init","ms","addEventListener","abort","setTimeout","getRequestClient","clearTimeout","shouldRetryHeader","retryAfter","parseInt","calculateRetryTimeoutSeconds","sleep","initialRetryDelay","maxRetryDelay","Number","isInteger","sleepSeconds","jitter","VERSION","post","client","bind","patch","put","delete","getAPIList","APIResource","set","__classPrivateFieldSet","hasNextPage","items","getPaginatedItems","nextPageInfo","getNextPage","nextInfo","nextOptions","params","searchParams","iterPages","page","WeakMap","Symbol","asyncIterator","item","Proxy","fromEntries","target","toLowerCase","requestOptionsKeys","obj","every","k","getPlatformProperties","Deno","build","normalizePlatform","os","normalizeArch","arch","version","EdgeRuntime","process","prototype","platform","browserInfo","getBrowserInfo","browser","navigator","browserPatterns","pattern","match","exec","userAgent","major","minor","_platformHeaders","startsWithSchemeRegexp","RegExp","isAbsoluteURL","test","n","env","Math","round","parseFloat","Boolean"],"sources":["C:\\Users\\seanm\\Desktop\\hackmit\\node_modules\\openai\\src\\core.ts"],"sourcesContent":["import { VERSION } from './version';\nimport { Stream } from './streaming';\nimport { APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError } from './error';\nimport type { Readable } from './_shims/node-readable';\nimport { getDefaultAgent, type Agent } from './_shims/agent';\nimport {\n  fetch,\n  isPolyfilled as fetchIsPolyfilled,\n  type RequestInfo,\n  type RequestInit,\n  type Response,\n} from './_shims/fetch.js';\nexport { type Response };\nimport { isMultipartBody } from './uploads';\nexport {\n  maybeMultipartFormRequestOptions,\n  multipartFormRequestOptions,\n  createForm,\n  type Uploadable,\n} from './uploads';\n\nconst MAX_RETRIES = 2;\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\ntype APIResponseProps = {\n  response: Response;\n  options: FinalRequestOptions;\n  controller: AbortController;\n};\n\nasync function defaultParseResponse<T>(props: APIResponseProps): Promise<T> {\n  const { response } = props;\n  if (props.options.stream) {\n    // Note: there is an invariant here that isn't represented in the type system\n    // that if you set `stream: true` the response type must also be `Stream<T>`\n    return new Stream(response, props.controller) as any;\n  }\n\n  const contentType = response.headers.get('content-type');\n  if (contentType?.includes('application/json')) {\n    const json = await response.json();\n\n    debug('response', response.status, response.url, response.headers, json);\n\n    return json as T;\n  }\n\n  // TODO handle blob, arraybuffer, other content types, etc.\n  const text = await response.text();\n  debug('response', response.status, response.url, response.headers, text);\n  return text as T;\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise<T> extends Promise<T> {\n  private parsedPromise: Promise<T> | undefined;\n\n  constructor(\n    private responsePromise: Promise<APIResponseProps>,\n    private parseResponse: (props: APIResponseProps) => PromiseOrValue<T> = defaultParseResponse,\n  ) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  _thenUnwrap<U>(transform: (data: T) => U): APIPromise<U> {\n    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    if (!this.parsedPromise) {\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\n    }\n    return this.parsedPromise;\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport abstract class APIClient {\n  baseURL: string;\n  maxRetries: number;\n  timeout: number;\n  httpAgent: Agent | undefined;\n\n  private fetch: Fetch;\n  protected idempotencyHeader?: string;\n\n  constructor({\n    baseURL,\n    maxRetries,\n    timeout = 600000, // 10 minutes\n    httpAgent,\n    fetch: overridenFetch,\n  }: {\n    baseURL: string;\n    maxRetries?: number | undefined;\n    timeout: number | undefined;\n    httpAgent: Agent | undefined;\n    fetch: Fetch | undefined;\n  }) {\n    this.baseURL = baseURL;\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries ?? MAX_RETRIES);\n    this.timeout = validatePositiveInteger('timeout', timeout);\n    this.httpAgent = httpAgent;\n\n    this.fetch = overridenFetch ?? fetch;\n  }\n\n  protected authHeaders(): Headers {\n    return {};\n  }\n\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n  protected defaultHeaders(): Headers {\n    return {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'User-Agent': this.getUserAgent(),\n      ...getPlatformHeaders(),\n      ...this.authHeaders(),\n    };\n  }\n\n  protected abstract defaultQuery(): DefaultQuery | undefined;\n\n  /**\n   * Override this to add your own headers validation:\n   */\n  protected validateHeaders(headers: Headers, customHeaders: Headers) {}\n\n  protected defaultIdempotencyKey(): string {\n    return `stainless-node-retry-${uuid4()}`;\n  }\n\n  get<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('get', path, opts);\n  }\n\n  post<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('post', path, opts);\n  }\n\n  patch<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('patch', path, opts);\n  }\n\n  put<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('put', path, opts);\n  }\n\n  delete<Req extends {}, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('delete', path, opts);\n  }\n\n  private methodRequest<Req extends {}, Rsp>(\n    method: HTTPMethod,\n    path: string,\n    opts?: PromiseOrValue<RequestOptions<Req>>,\n  ): APIPromise<Rsp> {\n    return this.request(Promise.resolve(opts).then((opts) => ({ method, path, ...opts })));\n  }\n\n  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    path: string,\n    Page: new (...args: any[]) => PageClass,\n    opts?: RequestOptions<any>,\n  ): PagePromise<PageClass, Item> {\n    return this.requestAPIList(Page, { method: 'get', path, ...opts });\n  }\n\n  private calculateContentLength(body: unknown): string | null {\n    if (typeof body === 'string') {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(body, 'utf8').toString();\n      }\n\n      if (typeof TextEncoder !== 'undefined') {\n        const encoder = new TextEncoder();\n        const encoded = encoder.encode(body);\n        return encoded.length.toString();\n      }\n    }\n\n    return null;\n  }\n\n  buildRequest<Req extends {}>(\n    options: FinalRequestOptions<Req>,\n  ): { req: RequestInit; url: string; timeout: number } {\n    const { method, path, query, headers: headers = {} } = options;\n\n    const body =\n      isMultipartBody(options.body) ? options.body.body\n      : options.body ? JSON.stringify(options.body, null, 2)\n      : null;\n    const contentLength = this.calculateContentLength(body);\n\n    const url = this.buildURL(path!, query);\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\n    const timeout = options.timeout ?? this.timeout;\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n    const minAgentTimeout = timeout + 1000;\n    if (\n      typeof (httpAgent as any)?.options?.timeout === 'number' &&\n      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)\n    ) {\n      // Allow any given request to bump our agent active socket timeout.\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n      // and without mutating agent we would need to create more of them.\n      // This tradeoff optimizes for performance.\n      (httpAgent as any).options.timeout = minAgentTimeout;\n    }\n\n    if (this.idempotencyHeader && method !== 'get') {\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n      headers[this.idempotencyHeader] = options.idempotencyKey;\n    }\n\n    const reqHeaders: Record<string, string> = {\n      ...(contentLength && { 'Content-Length': contentLength }),\n      ...this.defaultHeaders(),\n      ...headers,\n    };\n    // let builtin fetch set the Content-Type for multipart bodies\n    if (isMultipartBody(options.body) && !fetchIsPolyfilled) {\n      delete reqHeaders['Content-Type'];\n    }\n\n    // Strip any headers being explicitly omitted with null\n    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);\n\n    const req: RequestInit = {\n      method,\n      ...(body && { body: body as any }),\n      headers: reqHeaders,\n      ...(httpAgent && { agent: httpAgent }),\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: options.signal ?? null,\n    };\n\n    this.validateHeaders(reqHeaders, headers);\n\n    return { req, url, timeout };\n  }\n\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n  protected async prepareRequest(request: RequestInit, { url }: { url: string }): Promise<void> {}\n\n  protected makeStatusError(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: Headers | undefined,\n  ) {\n    return APIError.generate(status, error, message, headers);\n  }\n\n  request<Req extends {}, Rsp>(\n    options: PromiseOrValue<FinalRequestOptions<Req>>,\n    remainingRetries: number | null = null,\n  ): APIPromise<Rsp> {\n    return new APIPromise(this.makeRequest(options, remainingRetries));\n  }\n\n  private async makeRequest(\n    optionsInput: PromiseOrValue<FinalRequestOptions>,\n    retriesRemaining: number | null,\n  ): Promise<APIResponseProps> {\n    const options = await optionsInput;\n    if (retriesRemaining == null) {\n      retriesRemaining = options.maxRetries ?? this.maxRetries;\n    }\n\n    const { req, url, timeout } = this.buildRequest(options);\n\n    await this.prepareRequest(req, { url });\n\n    debug('request', url, options, req.headers);\n\n    if (options.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    const controller = new AbortController();\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n\n    if (response instanceof Error) {\n      if (options.signal?.aborted) {\n        throw new APIUserAbortError();\n      }\n      if (retriesRemaining) {\n        return this.retryRequest(options, retriesRemaining);\n      }\n      if (response.name === 'AbortError') {\n        throw new APIConnectionTimeoutError();\n      }\n      throw new APIConnectionError({ cause: response });\n    }\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      if (retriesRemaining && this.shouldRetry(response)) {\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\n      }\n\n      const errText = await response.text().catch(() => 'Unknown');\n      const errJSON = safeJSON(errText);\n      const errMessage = errJSON ? undefined : errText;\n\n      debug('response', response.status, url, responseHeaders, errMessage);\n\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n      throw err;\n    }\n\n    return { response, options, controller };\n  }\n\n  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n    options: FinalRequestOptions,\n  ): PagePromise<PageClass, Item> {\n    const request = this.makeRequest(options, null);\n    return new PagePromise<PageClass, Item>(this, request, Page);\n  }\n\n  buildURL<Req>(path: string, query: Req | undefined): string {\n    const url =\n      isAbsoluteURL(path) ?\n        new URL(path)\n      : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n\n    const defaultQuery = this.defaultQuery();\n    if (!isEmptyObj(defaultQuery)) {\n      query = { ...defaultQuery, ...query } as Req;\n    }\n\n    if (query) {\n      url.search = this.stringifyQuery(query);\n    }\n\n    return url.toString();\n  }\n\n  protected stringifyQuery(query: Record<string, unknown>): string {\n    return Object.entries(query)\n      .filter(([_, value]) => typeof value !== 'undefined')\n      .map(([key, value]) => {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n        }\n        if (value === null) {\n          return `${encodeURIComponent(key)}=`;\n        }\n        throw new Error(\n          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,\n        );\n      })\n      .join('&');\n  }\n\n  async fetchWithTimeout(\n    url: RequestInfo,\n    init: RequestInit | undefined,\n    ms: number,\n    controller: AbortController,\n  ): Promise<Response> {\n    const { signal, ...options } = init || {};\n    if (signal) signal.addEventListener('abort', () => controller.abort());\n\n    const timeout = setTimeout(() => controller.abort(), ms);\n\n    return this.getRequestClient()\n      .fetch(url, { signal: controller.signal as any, ...options })\n      .finally(() => {\n        clearTimeout(timeout);\n      });\n  }\n\n  protected getRequestClient(): RequestClient {\n    return { fetch: this.fetch };\n  }\n\n  private shouldRetry(response: Response): boolean {\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get('x-should-retry');\n\n    // If the server explicitly says whether or not to retry, obey.\n    if (shouldRetryHeader === 'true') return true;\n    if (shouldRetryHeader === 'false') return false;\n\n    // Retry on lock timeouts.\n    if (response.status === 409) return true;\n\n    // Retry on rate limits.\n    if (response.status === 429) return true;\n\n    // Retry internal errors.\n    if (response.status >= 500) return true;\n\n    return false;\n  }\n\n  private async retryRequest(\n    options: FinalRequestOptions,\n    retriesRemaining: number,\n    responseHeaders?: Headers | undefined,\n  ): Promise<APIResponseProps> {\n    retriesRemaining -= 1;\n\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n    //\n    // TODO: we may want to handle the case where the header is using the http-date syntax: \"Retry-After: <http-date>\".\n    // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#syntax for details.\n    const retryAfter = parseInt(responseHeaders?.['retry-after'] || '');\n\n    const maxRetries = options.maxRetries ?? this.maxRetries;\n    const timeout = this.calculateRetryTimeoutSeconds(retriesRemaining, retryAfter, maxRetries) * 1000;\n    await sleep(timeout);\n\n    return this.makeRequest(options, retriesRemaining);\n  }\n\n  private calculateRetryTimeoutSeconds(\n    retriesRemaining: number,\n    retryAfter: number,\n    maxRetries: number,\n  ): number {\n    const initialRetryDelay = 0.5;\n    const maxRetryDelay = 2;\n\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n    // just do what it says.\n    if (Number.isInteger(retryAfter) && retryAfter <= 60) {\n      return retryAfter;\n    }\n\n    const numRetries = maxRetries - retriesRemaining;\n\n    // Apply exponential backoff, but not more than the max.\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(numRetries - 1, 2), maxRetryDelay);\n\n    // Apply some jitter, plus-or-minus half a second.\n    const jitter = Math.random() - 0.5;\n\n    return sleepSeconds + jitter;\n  }\n\n  private getUserAgent(): string {\n    return `${this.constructor.name}/JS ${VERSION}`;\n  }\n}\n\nexport class APIResource {\n  protected client: APIClient;\n  constructor(client: APIClient) {\n    this.client = client;\n\n    this.get = client.get.bind(client);\n    this.post = client.post.bind(client);\n    this.patch = client.patch.bind(client);\n    this.put = client.put.bind(client);\n    this.delete = client.delete.bind(client);\n    this.getAPIList = client.getAPIList.bind(client);\n  }\n\n  protected get: APIClient['get'];\n  protected post: APIClient['post'];\n  protected patch: APIClient['patch'];\n  protected put: APIClient['put'];\n  protected delete: APIClient['delete'];\n  protected getAPIList: APIClient['getAPIList'];\n}\n\nexport type PageInfo = { url: URL } | { params: Record<string, unknown> | null };\n\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\n  #client: APIClient;\n  protected options: FinalRequestOptions;\n\n  protected response: Response;\n  protected body: unknown;\n\n  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {\n    this.#client = client;\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n\n  /**\n   * @deprecated Use nextPageInfo instead\n   */\n  abstract nextPageParams(): Partial<Record<string, unknown>> | null;\n  abstract nextPageInfo(): PageInfo | null;\n\n  abstract getPaginatedItems(): Item[];\n\n  hasNextPage(): boolean {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageInfo() != null;\n  }\n\n  async getNextPage(): Promise<AbstractPage<Item>> {\n    const nextInfo = this.nextPageInfo();\n    if (!nextInfo) {\n      throw new Error(\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\n      );\n    }\n    const nextOptions = { ...this.options };\n    if ('params' in nextInfo) {\n      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n    } else if ('url' in nextInfo) {\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n      for (const [key, value] of params) {\n        nextInfo.url.searchParams.set(key, value);\n      }\n      nextOptions.query = undefined;\n      nextOptions.path = nextInfo.url.toString();\n    }\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: AbstractPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise<\n    PageClass extends AbstractPage<Item>,\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\n  >\n  extends APIPromise<PageClass>\n  implements AsyncIterable<Item>\n{\n  constructor(\n    client: APIClient,\n    request: Promise<APIResponseProps>,\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n  ) {\n    super(\n      request,\n      async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options),\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport const createResponseHeaders = (\n  headers: Awaited<ReturnType<Fetch>>['headers'],\n): Record<string, string> => {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries(),\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    },\n  );\n};\n\ntype HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';\n\nexport type RequestClient = { fetch: Fetch };\nexport type Headers = Record<string, string | null | undefined>;\nexport type DefaultQuery = Record<string, string | undefined>;\nexport type KeysEnum<T> = { [P in keyof Required<T>]: true };\n\nexport type RequestOptions<Req extends {} = Record<string, unknown> | Readable> = {\n  method?: HTTPMethod;\n  path?: string;\n  query?: Req | undefined;\n  body?: Req | undefined;\n  headers?: Headers | undefined;\n\n  maxRetries?: number;\n  stream?: boolean | undefined;\n  timeout?: number;\n  httpAgent?: Agent;\n  signal?: AbortSignal | undefined | null;\n  idempotencyKey?: string;\n};\n\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<RequestOptions> = {\n  method: true,\n  path: true,\n  query: true,\n  body: true,\n  headers: true,\n\n  maxRetries: true,\n  stream: true,\n  timeout: true,\n  httpAgent: true,\n  signal: true,\n  idempotencyKey: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is RequestOptions => {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\nexport type FinalRequestOptions<Req extends {} = Record<string, unknown> | Readable> = RequestOptions<Req> & {\n  method: HTTPMethod;\n  path: string;\n};\n\ndeclare const Deno: any;\ndeclare const EdgeRuntime: any;\ntype Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';\ntype PlatformName =\n  | 'MacOS'\n  | 'Linux'\n  | 'Windows'\n  | 'FreeBSD'\n  | 'OpenBSD'\n  | 'iOS'\n  | 'Android'\n  | `Other:${string}`\n  | 'Unknown';\ntype Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';\ntype PlatformProperties = {\n  'X-Stainless-Lang': 'js';\n  'X-Stainless-Package-Version': string;\n  'X-Stainless-OS': PlatformName;\n  'X-Stainless-Arch': Arch;\n  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';\n  'X-Stainless-Runtime-Version': string;\n};\nconst getPlatformProperties = (): PlatformProperties => {\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n      'X-Stainless-Runtime': 'deno',\n      'X-Stainless-Runtime-Version': Deno.version,\n    };\n  }\n  if (typeof EdgeRuntime !== 'undefined') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\n      'X-Stainless-Runtime': 'edge',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n  // Check if Node.js\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(process.platform),\n      'X-Stainless-Arch': normalizeArch(process.arch),\n      'X-Stainless-Runtime': 'node',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n\n  const browserInfo = getBrowserInfo();\n  if (browserInfo) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': 'unknown',\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n      'X-Stainless-Runtime-Version': browserInfo.version,\n    };\n  }\n\n  // TODO add support for Cloudflare workers, etc.\n  return {\n    'X-Stainless-Lang': 'js',\n    'X-Stainless-Package-Version': VERSION,\n    'X-Stainless-OS': 'Unknown',\n    'X-Stainless-Arch': 'unknown',\n    'X-Stainless-Runtime': 'unknown',\n    'X-Stainless-Runtime-Version': 'unknown',\n  };\n};\n\ntype BrowserInfo = {\n  browser: Browser;\n  version: string;\n};\n\ndeclare const navigator: { userAgent: string } | undefined;\n\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo(): BrowserInfo | null {\n  if (!navigator || typeof navigator === 'undefined') {\n    return null;\n  }\n\n  // NOTE: The order matters here!\n  const browserPatterns = [\n    { key: 'edge' as const, pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'chrome' as const, pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'firefox' as const, pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'safari' as const, pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n  ];\n\n  // Find the FIRST matching browser\n  for (const { key, pattern } of browserPatterns) {\n    const match = pattern.exec(navigator.userAgent);\n    if (match) {\n      const major = match[1] || 0;\n      const minor = match[2] || 0;\n      const patch = match[3] || 0;\n\n      return { browser: key, version: `${major}.${minor}.${patch}` };\n    }\n  }\n\n  return null;\n}\n\nconst normalizeArch = (arch: string): Arch => {\n  // Node docs:\n  // - https://nodejs.org/api/process.html#processarch\n  // Deno docs:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  if (arch === 'x32') return 'x32';\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\n  if (arch === 'arm') return 'arm';\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\n  if (arch) return `other:${arch}`;\n  return 'unknown';\n};\n\nconst normalizePlatform = (platform: string): PlatformName => {\n  // Node platforms:\n  // - https://nodejs.org/api/process.html#processplatform\n  // Deno platforms:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  // - https://github.com/denoland/deno/issues/14799\n\n  platform = platform.toLowerCase();\n\n  // NOTE: this iOS check is untested and may not work\n  // Node does not work natively on IOS, there is a fork at\n  // https://github.com/nodejs-mobile/nodejs-mobile\n  // however it is unknown at the time of writing how to detect if it is running\n  if (platform.includes('ios')) return 'iOS';\n  if (platform === 'android') return 'Android';\n  if (platform === 'darwin') return 'MacOS';\n  if (platform === 'win32') return 'Windows';\n  if (platform === 'freebsd') return 'FreeBSD';\n  if (platform === 'openbsd') return 'OpenBSD';\n  if (platform === 'linux') return 'Linux';\n  if (platform) return `Other:${platform}`;\n  return 'Unknown';\n};\n\nlet _platformHeaders: PlatformProperties;\nconst getPlatformHeaders = () => {\n  return (_platformHeaders ??= getPlatformProperties());\n};\n\nexport const safeJSON = (text: string) => {\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return undefined;\n  }\n};\n\n// https://stackoverflow.com/a/19709846\nconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\nconst isAbsoluteURL = (url: string): boolean => {\n  return startsWithSchemeRegexp.test(url);\n};\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst validatePositiveInteger = (name: string, n: unknown): number => {\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\n    throw new Error(`${name} must be an integer`);\n  }\n  if (n < 0) {\n    throw new Error(`${name} must be a positive integer`);\n  }\n  return n;\n};\n\nexport const castToError = (err: any): Error => {\n  if (err instanceof Error) return err;\n  return new Error(err);\n};\n\nexport const ensurePresent = <T>(value: T | null | undefined): T => {\n  if (value == null) throw new Error(`Expected a value to be given but received ${value} instead.`);\n  return value;\n};\n\n/**\n * Read an environment variable.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env: string): string | undefined => {\n  if (typeof process !== 'undefined') {\n    return process.env?.[env] ?? undefined;\n  }\n  if (typeof Deno !== 'undefined') {\n    return Deno.env?.get?.(env);\n  }\n  return undefined;\n};\n\nexport const coerceInteger = (value: unknown): number => {\n  if (typeof value === 'number') return Math.round(value);\n  if (typeof value === 'string') return parseInt(value, 10);\n\n  throw new Error(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceFloat = (value: unknown): number => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') return parseFloat(value);\n\n  throw new Error(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceBoolean = (value: unknown): boolean => {\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'string') return value === 'true';\n  return Boolean(value);\n};\n\nexport const maybeCoerceInteger = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceInteger(value);\n};\n\nexport const maybeCoerceFloat = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceFloat(value);\n};\n\nexport const maybeCoerceBoolean = (value: unknown): boolean | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceBoolean(value);\n};\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function debug(action: string, ...args: any[]) {\n  if (typeof process !== 'undefined' && process.env['DEBUG'] === 'true') {\n    console.log(`OpenAI:DEBUG:${action}`, ...args);\n  }\n}\n\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\nexport const isRunningInBrowser = () => {\n  return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n    // @ts-ignore\n    typeof window.document !== 'undefined' &&\n    // @ts-ignore\n    typeof navigator !== 'undefined'\n  );\n};\n\nexport interface HeadersProtocol {\n  get: (header: string) => string | null | undefined;\n}\nexport type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;\n\nexport const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {\n  return typeof headers?.get === 'function';\n};\n\nexport const getHeader = (headers: HeadersLike, key: string): string | null | undefined => {\n  const lowerKey = key.toLowerCase();\n  if (isHeadersProtocol(headers)) return headers.get(key) || headers.get(lowerKey);\n  const value = headers[key] || headers[lowerKey];\n  if (Array.isArray(value)) {\n    if (value.length <= 1) return value[0];\n    console.warn(`Received ${value.length} entries for the ${key} header, using the first entry.`);\n    return value[0];\n  }\n  return value;\n};\n\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str: string | null | undefined): string => {\n  if (!str) return '';\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str).toString('base64');\n  }\n\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n\n  throw new Error('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}