{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = exports.isMultipartBody = exports.MultipartBody = exports.toFile = exports.isUploadable = exports.isBlobLike = exports.isFileLike = exports.isResponseLike = exports.fileFromPath = void 0;\nconst formdata_1 = require('openai/_shims/formdata');\nconst getMultipartRequestOptions_1 = require('openai/_shims/getMultipartRequestOptions');\nconst fileFromPath_1 = require('openai/_shims/fileFromPath');\nObject.defineProperty(exports, 'fileFromPath', {\n  enumerable: true,\n  get: function () {\n    return fileFromPath_1.fileFromPath;\n  }\n});\nconst node_readable_1 = require('openai/_shims/node-readable');\nconst isResponseLike = value => value != null && typeof value === 'object' && typeof value.url === 'string' && typeof value.blob === 'function';\nexports.isResponseLike = isResponseLike;\nconst isFileLike = value => value != null && typeof value === 'object' && typeof value.name === 'string' && typeof value.lastModified === 'number' && (0, exports.isBlobLike)(value);\nexports.isFileLike = isFileLike;\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = value => value != null && typeof value === 'object' && typeof value.size === 'number' && typeof value.type === 'string' && typeof value.text === 'function' && typeof value.slice === 'function' && typeof value.arrayBuffer === 'function';\nexports.isBlobLike = isBlobLike;\nconst isUploadable = value => {\n  return (0, exports.isFileLike)(value) || (0, exports.isResponseLike)(value) || (0, node_readable_1.isFsReadStream)(value);\n};\nexports.isUploadable = isUploadable;\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nasync function toFile(value, name, options = {}) {\n  var _a, _b, _c;\n  // If it's a promise, resolve it.\n  value = await value;\n  if ((0, exports.isResponseLike)(value)) {\n    const blob = await value.blob();\n    name || (name = (_a = new URL(value.url).pathname.split(/[\\\\/]/).pop()) !== null && _a !== void 0 ? _a : 'unknown_file');\n    return new formdata_1.File([blob], name, options);\n  }\n  const bits = await getBytes(value);\n  name || (name = (_b = getName(value)) !== null && _b !== void 0 ? _b : 'unknown_file');\n  if (!options.type) {\n    const type = (_c = bits[0]) === null || _c === void 0 ? void 0 : _c.type;\n    if (typeof type === 'string') {\n      options = {\n        ...options,\n        type\n      };\n    }\n  }\n  return new formdata_1.File(bits, name, options);\n}\nexports.toFile = toFile;\nasync function getBytes(value) {\n  var _a;\n  let parts = [];\n  if (typeof value === 'string' || ArrayBuffer.isView(value) ||\n  // includes Uint8Array, Buffer, etc.\n  value instanceof ArrayBuffer) {\n    parts.push(value);\n  } else if ((0, exports.isBlobLike)(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name}; props: ${propsForError(value)}`);\n  }\n  return parts;\n}\nfunction propsForError(value) {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map(p => `\"${p}\"`).join(', ')}]`;\n}\nfunction getName(value) {\n  var _a;\n  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || (\n  // For fs.ReadStream\n  (_a = getStringFromMaybeBuffer(value.path)) === null || _a === void 0 ? void 0 : _a.split(/[\\\\/]/).pop());\n}\nconst getStringFromMaybeBuffer = x => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\nconst isAsyncIterableIterator = value => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\nclass MultipartBody {\n  constructor(body) {\n    this.body = body;\n  }\n  get [Symbol.toStringTag]() {\n    return 'MultipartBody';\n  }\n}\nexports.MultipartBody = MultipartBody;\nconst isMultipartBody = body => body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\nexports.isMultipartBody = isMultipartBody;\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nconst maybeMultipartFormRequestOptions = async opts => {\n  if (!hasUploadableValue(opts.body)) return opts;\n  const form = await (0, exports.createForm)(opts.body);\n  return (0, getMultipartRequestOptions_1.getMultipartRequestOptions)(form, opts);\n};\nexports.maybeMultipartFormRequestOptions = maybeMultipartFormRequestOptions;\nconst multipartFormRequestOptions = async opts => {\n  const form = await (0, exports.createForm)(opts.body);\n  return (0, getMultipartRequestOptions_1.getMultipartRequestOptions)(form, opts);\n};\nexports.multipartFormRequestOptions = multipartFormRequestOptions;\nconst createForm = async body => {\n  const form = new formdata_1.FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\nexports.createForm = createForm;\nconst hasUploadableValue = value => {\n  if ((0, exports.isUploadable)(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue(value[k])) return true;\n    }\n  }\n  return false;\n};\nconst addFormValue = async (form, key, value) => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n  }\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if ((0, exports.isUploadable)(value)) {\n    const file = await toFile(value);\n    form.append(key, file);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map(entry => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n  } else {\n    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n  }\n};","map":{"version":3,"names":["exports","multipartFormRequestOptions","maybeMultipartFormRequestOptions","isMultipartBody","MultipartBody","toFile","isUploadable","isBlobLike","isFileLike","isResponseLike","fileFromPath","formdata_1","require","getMultipartRequestOptions_1","fileFromPath_1","defineProperty","enumerable","get","node_readable_1","value","url","blob","name","lastModified","size","text","slice","arrayBuffer","isFsReadStream","options","_b","_c","_a","URL","pathname","split","pop","File","bits","getBytes","getName","type","isView","ArrayBuffer","parts","push","isAsyncIterableIterator","chunk","Error","constructor","propsForError","props","Object","getOwnPropertyNames","map","p","join","getStringFromMaybeBuffer","filename","path","x","Buffer","String","undefined","Symbol","asyncIterator","body","toStringTag","opts","form","createForm","getMultipartRequestOptions","FormData","Promise","all","entries","key","addFormValue","Array","isArray","some","hasUploadableValue"],"sources":["C:\\Users\\seanm\\Desktop\\hackmit\\node_modules\\openai\\src\\uploads.ts"],"sourcesContent":["import { type RequestOptions } from './core';\nimport { type Readable } from './_shims/node-readable';\nimport { type BodyInit } from './_shims/fetch.js';\nimport { FormData, File, type Blob, type FilePropertyBag } from './_shims/formdata.js';\nimport { getMultipartRequestOptions } from './_shims/getMultipartRequestOptions';\nimport { fileFromPath } from './_shims/fileFromPath';\nimport { type FsReadStream, isFsReadStream } from './_shims/node-readable';\n\nexport { fileFromPath };\n\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\n\n/**\n * Typically, this is a native \"File\" class.\n *\n * We provide the {@link toFile} utility to convert a variety of objects\n * into the File class.\n *\n * For convenience, you can also pass a fetch Response, or in Node,\n * the result of fs.createReadStream().\n */\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\n\n/**\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\n */\nexport interface BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\n  readonly size: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\n  readonly type: string;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\n  text(): Promise<string>;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\n  slice(start?: number, end?: number): BlobLike;\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\n}\n\n/**\n * Intended to match web.File, node.File, node-fetch.File, etc.\n */\nexport interface FileLike extends BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\n  readonly lastModified: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\n  readonly name: string;\n}\n\n/**\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\n */\nexport interface ResponseLike {\n  url: string;\n  blob(): Promise<BlobLike>;\n}\n\nexport const isResponseLike = (value: any): value is ResponseLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.url === 'string' &&\n  typeof value.blob === 'function';\n\nexport const isFileLike = (value: any): value is FileLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.name === 'string' &&\n  typeof value.lastModified === 'number' &&\n  isBlobLike(value);\n\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.size === 'number' &&\n  typeof value.type === 'string' &&\n  typeof value.text === 'function' &&\n  typeof value.slice === 'function' &&\n  typeof value.arrayBuffer === 'function';\n\nexport const isUploadable = (value: any): value is Uploadable => {\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\n\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(\n  value: ToFileInput | PromiseLike<ToFileInput>,\n  name?: string | null | undefined,\n  options: FilePropertyBag | undefined = {},\n): Promise<FileLike> {\n  // If it's a promise, resolve it.\n  value = await value;\n\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\n\n    return new File([blob as any], name, options);\n  }\n\n  const bits = await getBytes(value);\n\n  name ||= getName(value) ?? 'unknown_file';\n\n  if (!options.type) {\n    const type = (bits[0] as any)?.type;\n    if (typeof type === 'string') {\n      options = { ...options, type };\n    }\n  }\n\n  return new File(bits, name, options);\n}\n\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\n  let parts: Array<BlobPart> = [];\n  if (\n    typeof value === 'string' ||\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer\n  ) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk as BlobPart); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(\n      `Unexpected data type: ${typeof value}; constructor: ${\n        value?.constructor?.name\n      }; props: ${propsForError(value)}`,\n    );\n  }\n\n  return parts;\n}\n\nfunction propsForError(value: any): string {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n\nfunction getName(value: any): string | undefined {\n  return (\n    getStringFromMaybeBuffer(value.name) ||\n    getStringFromMaybeBuffer(value.filename) ||\n    // For fs.ReadStream\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\n  );\n}\n\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\n\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\nexport class MultipartBody {\n  constructor(public body: Readable | BodyInit) {}\n  get [Symbol.toStringTag](): string {\n    return 'MultipartBody';\n  }\n}\n\nexport const isMultipartBody = (body: any): body is MultipartBody =>\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async <T extends {} = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  if (!hasUploadableValue(opts.body)) return opts;\n\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const multipartFormRequestOptions = async <T extends {} = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\n\nconst hasUploadableValue = (value: unknown): boolean => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue((value as any)[k])) return true;\n    }\n  }\n  return false;\n};\n\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\n    );\n  }\n\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (isUploadable(value)) {\n    const file = await toFile(value);\n    form.append(key, file as File);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\n    );\n  } else {\n    throw new TypeError(\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\n    );\n  }\n};\n"],"mappings":";;;;;qBAGAA,OAAA,CAAAC,2BAAA,GACAD,OAAA,CAAAE,gCAAA,GACAF,OAAA,CAAAG,eAAA,GAGSH,OAAA,CAAAI,aAAA,GAFTJ,OAAA,CAAAK,MAAA,GAmDOL,OAAM,CAAAM,YAAc,G,OAEzB,CAAAC,UAAY,G,OACZ,CAAAC,UAAgB,G,OAChB,CAAAC,cAAiB,GAJNT,OAAA,CAAAU,YAAc,GAMpB,KAAM;MAEXC,UAAY,GAAAC,OAAK,yBAAQ;MACzBC,4BAA8B,GAAAD,OAAA;MAC9BE,cAAa,GAAAF,OAAY,6BAAa;MACtC,CAAAG,cAAA,CAAAf,OAAW,gBAAO;EALPgB,UAAA,MAAU;EAOvBC,GAAA,WAAAA,CAAA;;;;AAIO,MAAMC,eAAc,GAAAN,OACzB,8BAAa;MACbH,cAAY,GAAKU,KAAQ,I,KACzB,IAAO,Q,OACPA,KAAO,KAAM,QAAS,I,OACtBA,KAAO,CAAAC,GAAM,KAAI,QAAK,I,OACtBD,KAAO,CAAAE,IAAM,KAAK,UAAK;OACvB,CAAAZ,cAAa,GAAAA,cAAgB;AAPlB,MAAAD,UAAA,GAAUW,KAAA,IAShBA,KAAM,Y,OACXA,KAAO,iBACP,OAAAA,KAAA,CAAAG,IAAA,iBAFW,OAAAH,KAAA,CAAAI,YAAY,aAEvB,IAIF,IAAAvB,OAAA,CAAAO,UAAA,EAAAY,KAAA;;;;;;oDAQGA,KAAA,iBACI,OAAKA,KAAA,CAAUK,IAAA,KACpB,QACA,I,yCAGAL,KAAA,CAAAM,IAAA,mB,OACKN,KAAG,CAAAO,KAAM,KAAM,c,OAEhBP,KAAA,CAAAQ,WAAA,eAAoB;QACtBpB,UAAU,GAAGA,UAAM;kBACnB,GAAIY,KAAK;UAGV,GAAAnB,OAAA,CAAAQ,UAAA,EAAAW,KAAA,KAED,IAAAnB,OAAU,CAAAS,cAAS,EAASU,KAAK,CAAC,IAElC,IAAID,eAAK,CAAAU,cAAQ,EAAMT,KAAA;;QAIrBb,YAAW,GAAIA,YAAK;;;;;AAMxB;AA3BA;AA6BA;;;eAGWD,MAAKA,CAAAc,KAAK,EAAAG,IAAQ,EAAAO,OAAA;QACzB,EAAAC,EAAA,EAAAC,EAAA;;UAGA,MAAMZ,KAAK;MACZ,IAAAnB,OAAA,CAAAS,cAAA,EAAAU,KAAA;UAAME,IAAI,SAAAF,KAAA,CAAAE,IAAA,EAAU;QACnB,KACDC,IAAA,G,CAAMU,EAAA,GACL,IAAAC,GAAA,CAAAd,KAAA,CAAAC,GAAA,EAAAc,QAAwB,CAAKC,KAAE,UAAAC,GAAA,gBAAAJ,EAAA,UAA0C,IACzEA,EAAA,GACA,cAAW,CAAM;eACfrB,UAAW,CAAA0B,IAAmB,CAAC,CAAAhB,IAAA,GAAAC,IAAA,EAAAO,OAAA;;QAElCS,IAAA,SAAAC,QAAA,CAAApB,KAAA;WAAMG,IAAA,IAAAQ,EAAA,GAAAU,OAAA,CAAArB,KAAA,eAAAW,EAAA,cAAAA,EAAA;cACC,CAAAW,IAAI;UAKXA,IAAA,IAAAV,EAAA,GAAAO,IAAA,iBAAAP,EAAA,uBAAAA,EAAA,CAAAU,IAAA;IAED,WAAOA,IAAM;MACdZ,OAAA;QAAA,GAAAA,OAAA;QAAAY;MAAA;IAED;;SAEE,IAAO9B,UAAU,CAAG0B,IAAG,CAAEC,IAAG,EAAAhB,IAAK,EAAIO,OAAM;AAC7C;AAEA7B,OAAA,CAAAK,MAAS,GAAQA,MAAU;;MACzB2B,EAAA;WAEE;aACAb,KAAA,aAAoB,I,WACpB,CAAAuB,MAAA,CAAAvB,KAAA;EAAA;EAEHA,KAAA,YAAAwB,WAAA,EAED;IACEC,KAAI,CAAAC,IAAA,CAAO1B,KAAC,CAAK;SAAU,MAAO,EAAEnB,OAAA,CAAAO,UAAA,EAAAY,KAAA;IACpCyB,KAAI,CAAAC,IAAA,CAAO,MAAM1B,KAAK,CAAAQ,WAAW,GAAI;SAAqB,IAC1DmB,uBAAiB,CAAA3B,KAAA;EAAA,EACjB;IAEF,WAAM,MAAA4B,KAAA,IAAuB5B,KAAI;MAGpByB,KAAA,CAAAC,IAAA,CAAAE,KAAa;IACxB;SAAmB;IAA4B,MAAC,IAAAC,KAAA,CAChD,yBAAwB,OAAA7B,KAAA,kBACtB,CAAAa,EAAA,GAAAb,KAAO,aAAgBA,KAAA,uBAAAA,KAAA,CAAA8B,WAAA,cAAAjB,EAAA,cACxB,SACFA,EAAA,CAAAV,IALD,YAAA4B,aAAA,CAAA/B,KAAA,CAKC,EAEM;EAAM;EAGb,OAAAyB,KAAA;;;QAGGO,KAAA,GAAAC,MAAA,CAAAC,mBAAA,CAAAlC,KAAA;EACI,OAAM,IAAAgC,KAAA,CAAAG,GAAA,CAAAC,CAAA,QAAAA,CAAA,GAAgC,EAAAC,IAAG,KAC9C,IAAuB;;SAEahB,OAAOA,CAAArB,KAAK;MAEhDa,EAAA;SAEAyB,wBAAA,CAAAtC,KAAA,CAAAG,IAAA,KAPWmC,wBAAA,CAAAtC,KAAA,CAAAuC,QAAgC;EAStC;EAGL,CAAA1B,EAAA,GAAMyB,wBAAa,CAAAtC,KAAA,CAAAwC,IAAU,CAAC,MAAK,IAAK,IAAC3B,EAAA,uBAAAA,EAAA,CAAAG,KAAA,UAAAC,GAAA;AAE3C;AALa,MAAAqB,wBAAA,GAAAG,CAA2B;EAOjC,IAAM,OAAAA,CAAA,KAAa,QAAoC,SAA0CA,CAAA;MACtG,OAAMC,MAAO,KAAI,eAAAD,CAAQ,YAAGC,MAAA,SAAAC,MAAA,CAAAF,CAAA;SAC5BG,SAAc;;AAEhB,MAAEjB,uBAAA,GAAA3B,KAAA,IAJWA,KAAA,YAAU,OAAAA,KAAA,KAIrB,mBAAAA,KAAA,CAAA6C,MAAA,CAAAC,aAAA;AAEF,MAAM7D,aAAA;aACA6C,CAAAiB,IAAA;QAAqB,CAAAA,IAAA,GAAOA,IAAK;;aACX,CAAAC,WAAiB,IAAC;IAC5C,OAAI,eAAgB;;;qBAE2B,GAAO/D,aAAK;qBACxD,GAAA8D,IAAA,I,IACF,WAAAA,IAAA,iBAAAA,IAAA,CAAAA,IAAA,IAAAA,IAAA,CAAAF,MAAA,CAAAG,WAAA;OACD,CAAAhE,eAAa,GAAAA,eAAA;AACf;AAEA;;;MAEED,gCAAmB,SAAAkE,IAAA;yBACP,CAAAA,IACR,CAAAF,IAAA,UAAAE,IAAA;QAEHC,IAAA,aAAArE,OAAA,CAAAsE,UAAA,EAAAF,IAAA,CAAAF,IAAA;SAED,IAAArD,4BAAA,CAAA0D,0BAAyC,EAAAF,IAAA,EAAAD,IAAA;;QAEvClE,gCAAgC,GAAAA,gCAAA;MACjCD,2BAAA,SAAAmE,IAAA;YAAM,GAAI,UAAApE,OAAA,CAAAsE,UAAa,EAAMF,IAAE,CAAAF,IAAA;SAC9B,IAAArD,4BAAiC,CAAA0D,0BAAA,EAAAF,IAAA,EAAAD,IAAA;;OAElC,CAAAnE,2BAAA,GAAAA,2BAAA;gBAAU,GAAM,MAAOiE,IAAC,IAAQ;QAC/BG,IAAA,GAAM,IAAA1D,UAAY,CAAA6D,QAAW;QAC9BC,OAAA,CAAAC,GAAA,CAAAtB,MAAA,CAAAuB,OAAA,CAAAT,IAAA,QAAAZ,GAAA,GAAAsB,GAAA,EAAAzD,KAAA,MAAA0D,YAAA,CAAAR,IAAA,EAAAO,GAAA,EAAAzD,KAAA;SAAMkD,IAAI;;OAIV,CAAAC,UAAA,GAAAA,UAAA;wBAAM,GAAAnD,KAAA;QACL,EAAAnB,OAAM,CAAIM,YACR,EAAAa,KAAA;MAEH2D,KAAA,CAAAC,OAAA,CAAA5D,KAAA,UAAAA,KAAA,CAAA6D,IAAA,CAAAC,kBAAA;EACD,IAAA9D,KAAA,WAAAA,KAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}